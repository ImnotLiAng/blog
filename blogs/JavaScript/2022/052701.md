---
title: javascript 闭包
date: 2022/05/27
tags:
 - javascript
categories:
 - JavaScript
---


闭包： 引用了另一个函数作用域中变量的函数

前置知识：作用域、执行上下文与变量对象（也叫活动对象）

### 什么是作用域

作用域就是变量和函数的有效范围

### 什么是上下文

上下文主要分为全局上下文和函数上下文（eval 方法内部存在第三种），变量和函数的上下文决定它们可以访问哪些数据和行为，每个上下文都有一个关联的变量对象，里面存放了在这个上下文定义的所有变量和函数

上下文的代码在执行的时候会创建一个作用域链--决定了上下文中的代码访问变量和函数的顺序


### 作用域链是怎么产生的

在定义函数时，就会为它创建作用域链，并保存在内部的 [[scope]] 属性中，在调用函数时会创建相应的执行上下文，然后通过复制函数的 [[scope]] 值来创建其作用域链，并创建函数的变量对象，推入作用域链的前端

### 闭包会产生什么影响
当函数执行完，其作用域链被销毁，但函数的**变量对象**仍保留在内部函数的作用域链域中，因为内部函数引用了这些变量

一般变量对象会随作用域链被销毁而销毁，而闭包阻止了这个行为，只有当作用域链上含这些被阻止销毁的变量的函数都被销毁后，这些变量才会被销毁



### 闭包容易导致内存泄漏
原因：新的闭包变量的作用域上存在旧的闭包变量<br />
如：
```js
var oldVal = ""
function replace() {
  function unUsed() {
    console.log(oldVal); // 引用旧值
  }
  const newVal = {
    function set() {
      console.log("test")
    }
  }
  oldVal = newVal; // 新值的作用域上存在旧值
}

setInterval(replace, 1000);
```
由于 unUsed 函数中引用了 oldVal，unUsed 的作用域链上存在 oldVal，而 newVal 的 set 函数与 unUsed 函数使用同一作用域链，因此，每次调用 replace 时，新赋值的 oldVal 的 set 函数的作用域链上都存在上一次 oldVal 对象，从而导致内存泄漏

## 参考
《JavaScript高级程序设计》